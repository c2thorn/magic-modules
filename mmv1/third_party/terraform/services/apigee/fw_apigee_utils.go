// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/apigee/fw_resource_apigee_keystores_aliases_key_cert_file.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package apigee

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"google.golang.org/api/googleapi"
)

func RetryWithContext(ctx context.Context, opt transport_tpg.RetryOptions) error {
	// Create a channel to receive the result of the retry operation.
	doneCh := make(chan error, 1)

	// Run the original blocking Retry function in a separate goroutine.
	go func() {
		doneCh <- transport_tpg.Retry(opt)
	}()

	// Use a select statement to wait for either the operation to finish
	// or the context to be cancelled.
	select {
	case err := <-doneCh:
		// The retry operation completed (either with success or a non-retryable error).
		return err
	case <-ctx.Done():
		// The context was cancelled (e.g., user pressed Ctrl+C).
		return ctx.Err()
	}
}

// sendRequestRawBodyFramework is a Plugin Framework-style helper for sending HTTP requests
// with a raw io.Reader body, such as for multipart/form-data uploads. It includes
// retry logic and framework-native error and logging.
func sendRequestRawBodyFramework(ctx context.Context, opts SendRequestRawBodyOptions) (map[string]interface{}, diag.Diagnostics) {
	var diags diag.Diagnostics

	tflog.Trace(ctx, "Executing raw body request", map[string]interface{}{
		"url":    opts.RawURL,
		"method": opts.Method,
	})

	reqHeaders := make(http.Header)
	reqHeaders.Set("User-Agent", opts.UserAgent)
	reqHeaders.Set("Content-Type", opts.ContentType)

	if opts.Config.UserProjectOverride && opts.Project != "" {
		reqHeaders.Set("X-Goog-User-Project", opts.Project)
	}

	timeout := opts.Timeout
	if timeout == 0 {
		timeout = 2 * time.Minute
	}

	var httpResp *http.Response

	// Use the context-aware retry helper.
	err := RetryWithContext(ctx, transport_tpg.RetryOptions{
		RetryFunc: func() error {
			// **CORRECTION HERE:** Access the .Client field directly.
			// It is not a function and does not return an error.
			client := opts.Config.Client

			// The body (an io.Reader) can often only be read once. For retries to work,
			// we must use an io.ReadSeeker and seek back to the beginning before each attempt.
			// A *bytes.Buffer implements this interface automatically.
			if bodySeeker, ok := opts.Body.(io.ReadSeeker); ok {
				bodySeeker.Seek(0, io.SeekStart)
			}

			httpReq, err := http.NewRequestWithContext(ctx, opts.Method, opts.RawURL, opts.Body)
			if err != nil {
				return fmt.Errorf("error creating HTTP request: %w", err)
			}
			httpReq.Header = reqHeaders

			httpResp, err = client.Do(httpReq)
			if err != nil {
				return fmt.Errorf("error sending request: %w", err)
			}

			if err := googleapi.CheckResponse(httpResp); err != nil {
				return err
			}

			return nil
		},
		Timeout: timeout,
	})

	if err != nil {
		diags.AddError("API Request Failed", fmt.Sprintf("request to %s failed with retries: %s", opts.RawURL, err.Error()))
		return nil, diags
	}

	if httpResp == nil {
		diags.AddError("API Response Error", "Request was successful, but the HTTP response was nil. This is an unexpected error.")
		return nil, diags
	}
	defer googleapi.CloseBody(httpResp)

	if httpResp.StatusCode == http.StatusNoContent {
		return nil, diags
	}

	result := make(map[string]interface{})
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		diags.AddError("API Response Decode Error", fmt.Sprintf("failed to decode JSON response body: %s", err.Error()))
		return nil, diags
	}

	tflog.Trace(ctx, "Raw body request successful")
	return result, diags
}

// And the SendRequestRawBodyOptions struct from the previous answer
type SendRequestRawBodyOptions struct {
	Config      *transport_tpg.Config
	Method      string
	Project     string
	RawURL      string
	UserAgent   string
	Body        io.Reader
	ContentType string
	Timeout     time.Duration
}
